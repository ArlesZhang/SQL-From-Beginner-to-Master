# SQL 核心思维与性能优化精要 | By Arles Zhang & GPT5 
> 2025.9.11

## 1️⃣ SQL 的 7 大核心思维模式
> 掌握这些思维模式，能让你在写 SQL 时有全局观，快速拆解复杂需求。

| # | 思维模式 | 核心定义 | 适用场景 | 直觉口诀 |
|---|----------|----------|----------|----------|
| 1 | **流水线执行** | SQL 是一条数据加工流水线 | 单表加工、分步变换 | 一步步加工数据 |
| 2 | **集合运算** | 把两个结果集当集合做并/交/差 | 两个结果集的关系 | 纵向合并结果集 |
| 3 | **集合连接** | 按条件横向拼接表 | 多表补充信息 | 横向扩展数据 |
| 4 | **声明式** | 说出你要的结果，不写过程 | 结果导向查询 | 结果导向，细节交给优化器 |
| 5 | **集合** | 批量处理，而不是逐行 | 去重、聚合 | 一次性处理整个集合 |
| 6 | **分层抽象** | 复杂需求拆成多层 | 多层聚合、复杂逻辑 | 复杂需求 = 简单集合组合 |
| 7 | **最小化数据集** | 尽早过滤、尽早聚合 | 性能优化 | 数据越早变小，后面越轻松 |

---

## 2️⃣ DISTINCT vs GROUP BY vs 窗口函数
- **DISTINCT**：去重（保留唯一组合）
- **GROUP BY**：分组聚合（每组一行）
- **窗口函数**：保留明细 + 分组统计（加辅助列）

**直觉判断**：
> 只去重 → DISTINCT  
> 分组聚合 → GROUP BY  
> 保留明细 + 分组统计 → 窗口函数

---

## 3️⃣ 集合运算的列对齐规则
- 列数必须相同
- 列位置必须一致（按位置对齐，不看列名）
- 列类型必须兼容（必要时 CAST 转换）
- 最终列名取第一个 SELECT 的列名

**直觉**：
> SQL 集合运算像“叠扑克牌”，牌数一样、顺序一样才能对齐。

---

## 4️⃣ Hive 分区表与分区裁剪
- **分区表**：按分区字段值建目录（`dt=2025-09-01`）
- **分区裁剪**：WHERE 条件直接命中分区字段 → 只扫描对应目录
- **分区字段设计**：高频过滤字段优先，粒度适中
- **分区 vs 分桶**：
  - 分区：不同目录，减少扫描量
  - 分桶：同目录下不同文件，优化 Join / 聚合
- **动态分区插入**：`INSERT OVERWRITE TABLE ... PARTITION(...)`，可静态/动态生成分区

**直觉**：
> 分区 = 按目录切，裁剪扫描量  
> 分桶 = 按文件切，对齐 Join

---

## 5️⃣ 分区 / 分桶的大白话类比
- **分区**：仓库的不同房间（按日期、地区分）
- **分桶**：房间里的不同货架（按哈希值分）
- **分区裁剪**：只进需要的房间
- **桶映射 Join**：只让相同货架的货物对比

---

## 6️⃣ 核心直觉总结
1. SQL 是集合语言，不是过程语言 → 想集合，不想循环
2. 复杂需求拆成简单集合组合 → CTE / 子查询分层
3. 性能优化的第一步是减少扫描量 → 分区裁剪、尽早过滤
4. 分区 / 分桶是物理存储优化的两种方式 → 目录 vs 文件

---

## 📌 今日关键词
`SQL 思维模式` `DISTINCT vs GROUP BY` `集合运算列对齐` `Hive 分区表` `分区裁剪` `分桶优化`

---

## 💬 思考 / 互动问题
1. 你在写 SQL 时，更多是用 **过程式思维** 还是 **集合思维**？为什么？  
2. 如果一张 Hive 表每天有 1000 个分区，你会怎么设计分区字段来平衡性能和存储？  
3. 你能想到哪些业务场景下，**分桶** 比 **分区** 更适合用来优化查询吗？

---

Welcome to follow My GitHub
